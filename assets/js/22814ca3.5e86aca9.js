"use strict";(globalThis.webpackChunktrustification_io=globalThis.webpackChunktrustification_io||[]).push([[5533],{979:e=>{e.exports=JSON.parse('{"permalink":"/blog/2023/01/31/tuf","editUrl":"https://github.com/trustification/trustification.github.io/tree/main/blog/2023-01-31-tuf.md","source":"@site/blog/2023-01-31-tuf.md","title":"The Update Framework (TUF)","description":"TUF seems to pop again and again when learning about Secure Supply-Chain","date":"2023-01-31T00:00:00.000Z","tags":[],"readingTime":18.36,"hasTruncateMarker":true,"authors":[{"name":"Daniel Bevenius","title":"Maintainer","url":"https://github.com/danbev","imageURL":"https://github.com/danbev.png","key":"danbev","page":null}],"frontMatter":{"title":"The Update Framework (TUF)","authors":"danbev","tags":[]},"unlisted":false,"prevItem":{"title":"Continuing the Adventure with the CycloneDX Maven Plugin","permalink":"/blog/2023/02/10/cyclonedx-maven-plugin-adventure-continues"},"nextItem":{"title":"Is this a cryptographic key which I see before me?","permalink":"/blog/2023/01/25/keys"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(6540);const s={},o=a.createContext(s);function i(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:t},e.children)}},9216:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var a=n(979),s=n(4848),o=n(8453);const i={title:"The Update Framework (TUF)",authors:"danbev",tags:[]},r=void 0,d={authorsImageUrls:[void 0]},c=[{value:"Root Metadata",id:"root-metadata",level:4},{value:"Root metadata",id:"root-metadata-1",level:4},{value:"Targets metadata",id:"targets-metadata",level:4},{value:"Snapshot metadata",id:"snapshot-metadata",level:4},{value:"Timestamp metadata",id:"timestamp-metadata",level:4},{value:"Signing root.json",id:"signing-rootjson",level:4},{value:"Generate the TUF repository",id:"generate-the-tuf-repository",level:4},{value:"TUF client/consumer",id:"tuf-clientconsumer",level:3},{value:"TUF usage in Sigstore",id:"tuf-usage-in-sigstore",level:3}];function h(e){const t={a:"a",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"TUF seems to pop again and again when learning about Secure Supply-Chain\nSecurity (SSCS). The goal of this post is to get some hands-on experience\nwith TUF, showing examples that will hopefully clarify TUF concepts, and\nthe reason for using it in projects like Sigstore."}),"\n",(0,s.jsx)(t.p,{children:'As the name "The Update Framework" implies this is a framework for update\nsystems, and doing so in a secure way. What is getting updated could be\nanything, it could be software packages, source files, certificates, public\nkeys, etc. And by following this "framework", updates can be performed in a\nsecure way.'}),"\n",(0,s.jsx)(t.p,{children:'Producers want the things they produce to be available to consumers, and they\nwant to make sure that consumers are getting updates for these things. I\'m using\n"things" just to make it clear that this does not have to be software packages\nwhich might be what first comes to mind.'}),"\n",(0,s.jsx)(t.p,{children:"Lets take a look what this might look like without TUF:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+     +---------------------+                      +----------+\n  | Producer  |     | Distribution server |                      | Consumer |\n  |-----------+     |---------------------+                      |----------|\n  | thing_v1  | --\x3e | thing_v1            | -------------------\x3e | thing_v1 |\n  +-----------+     +---------------------+                      +----------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"So we have a producer that has something that it makes available to consumer's\nvia a distribution server. The consumer uses this thing by downloading it from\nthe distribution server in some manner. If the distribution server just allows\nthe consumer to poll and download the thing/artifact, then it will be up to the\nconsumer code to decide when it should poll to check for updates and update if\nneeded."}),"\n",(0,s.jsx)(t.p,{children:"For example, lets say that a man in the middle (MITM) attack is put in place\nand the consumer is no longer talking to the distribution server but instead\nto server controlled by an attacker which provides the consumer with a malicious\nartifacts:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+     +---------------------+     +----------+     +----------+\n  | Producer  |     | Distribution server |     | MITM     |     | Consumer |\n  |-----------+     |---------------------+     |          |     |----------|\n  | thing_v1  | --\x3e | thing_v1            |     | evil_v1  | --\x3e | thing_v1 |\n  +-----------+     +---------------------+     +----------+     +----------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"An attacker may also target the distribution server itself and modify the\nartifacts that the consumers download:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+     +---------------------+                      +----------+\n  | Producer  |     | Distribution server |                      | Consumer |\n  |-----------+     |---------------------+                      |----------|\n  | thing_v1  | --\x3e | thing_v1 (evil_v1)  | ------------------\x3e  | thing_v1 |\n  +-----------+     +---------------------+                      +----------+\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This type of attack is refered to as ",(0,s.jsx)(t.code,{children:"Arbitary software installation"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Another attack against the distribution server is where the attacker prevents\nthe consumer from getting updates, and instead provides the consumer with an\nolder version which might contain a known vulnerabilty."}),"\n",(0,s.jsx)(t.p,{children:"This would be the current state where the correct/latest version is being used:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+     +---------------------+                      +----------+\n  | Producer  |     | Distribution server |                      | Consumer |\n  |-----------+     |---------------------+                      |----------|\n  | thing_v3  | --\x3e | thing_v3            | ------------------\x3e  | thing_v3 |\n  +-----------+     +---------------------+                      +----------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"The attacker then changes the version on the distribution server to an older\nversion, causing the consumer to downgrade, or rollback to that version:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+     +---------------------+                      +----------+\n  | Producer  |     | Distribution server |                      | Consumer |\n  |-----------+     |---------------------+                      |----------|\n  | thing_v3  | --\x3e | thing_v2 (evil_v2)  | ------------------\x3e  | thing_v2 |\n  +-----------+     +---------------------+                      +----------+\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This type of attack is refered to as ",(0,s.jsx)(t.code,{children:"Rollback attack"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["There are other ",(0,s.jsx)(t.a,{href:"https://theupdateframework.io/security/",children:"attacks"})," but these\nI found helped me better understand the metadata that is provided by TUF."]}),"\n",(0,s.jsx)(t.p,{children:"A simplified overview of this can be seen below and I'm going into more\ndetails later in the document."}),"\n",(0,s.jsxs)(t.p,{children:["What I'd like to convey with this is that the producer will update the TUF\nrepository by creating ",(0,s.jsx)(t.code,{children:"metadata"})," about the artifact(s) that are going to be\nmade available. This metadata is signed by one or more keys.\nThe motivation for signing is that we want to prevent the situation above where\nan attacker is able to replace an artifact with an older version, or a modified\nversion. Having the metadata signed for each version means that it would not be\npossible for an attacker to do this as the TUF client framework will verify\nsignatures."]}),"\n",(0,s.jsx)(t.p,{children:'In TUF, the "distribution server" in the above scenarios will have a TUF\nrepository integrated into it. This repository will be updated by the producer,\nand the consumer in the above scenarios will be replaced by a TUF client:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +------------------+\n  | Producer  |         | TUF Repository      | <-----------  | TUF Client       |\n  |-----------+ update  |---------------------+               |------------------|\n  | thing_v1  | ------\x3e | Metadata (signed)   | ------------\x3e | Metadata (signed)|\n  +-----------+         +---------------------+               +------------------+\n                                                ------------\x3e | thing_v1         |\n                                                              +------------------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"Notice that in addition to the metadata that exists on the TUF repository there\nis also metadata on the TUF consumer/client side. This metadata is downloaded\nand frequently resigned, and it has an short expiration date. This is how the\nTUF framework enforces updates actually take place. Because the TUF client\nframework checks the expiration and the signature of the metadata file, it\ncan detect if the expiration date has passed. If there has not been any updates\nand the expiration date has passed, perhaps a certain number of times, it can\ntake action to notify the client side software about this situation. This is how\nTUF can enforce that updates actually get applied to the consumer."}),"\n",(0,s.jsx)(t.p,{children:"This metadata is also signed as we don't want an attacker to be able to serve\nthe client with a metadata file they crafted themselves, which might have\nenabled the attacker to trick the consumer into thinking that there are no\nupdates and force the consumer to be stuck on an older version."}),"\n",(0,s.jsx)(t.p,{children:'Hopefully this has provided an overview and some idea about the metadata and\nthe signing in TUF. Later we will see a concrete example of the metadata files\nto get "feel" for what they look like.'}),"\n",(0,s.jsx)(t.p,{children:"So, we have mentioned metadata files and signing. The following is an attempt\nto visualize where the metadata files exist."}),"\n",(0,s.jsx)(t.p,{children:"Initially, we would have the following metadata files:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +---------------+\n  | Producer  |         | TUF Repository      |               | TUF Consumer  |\n  |-----------+ update  |---------------------+               |---------------|\n  | Keys      | ------\x3e | Metadata            |               | Metadata      |\n  +-----------+         | 1.root.json         |               | root.json     |\n  | Metadata  |         | 1.targets.json      |               +---------------+\n  | root.json |         | 1.snapshot.json     |\n  +-----------+         | timestamp.json      |\n  | thing_v1  |         +---------------------+\n  +-----------+         | thing_v1            |\n                        +---------------------+\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Initially, before the client has interacted with the TUF repository, the client\nhas a trusted root.json metadata file. This file is shipped with the client and\nit does not matter if it's expire date has passed, as it will get updated once\nthe client interacts with the TUF reporitory which is part of the client\n",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#detailed-client-workflow",children:"workflow"}),"\nof TUF's specification."]}),"\n",(0,s.jsxs)(t.p,{children:["The client starts by ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#load-trusted-root",children:"loading"})," this trusted root file."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, client proceeds to the ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#update-root",children:"download"})," <version>.root.json files from the TUF repository until it has\nreached the latest:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +---------------+\n  | Producer  |         | TUF Repository      | <-----------  | TUF Consumer  |\n  |-----------+ update  |---------------------+               |---------------|\n  | Keys      | ------\x3e | Metadata            | ------------\x3e | Metadata      |\n  +-----------+         | 1.root.json         |               | root.json     |\n  | Metadata  |         | 1.targets.json      |               +---------------+\n  | root.json |         | 1.snapshot.json     |\n  +-----------+         | timestamp.json      |\n  | thing_v1  |         +---------------------+\n  +-----------+         | thing_v1            |\n                        +---------------------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"Notice that the root.json is written on the client side without the version\nprefix. This will be used to verify the files that are download later."}),"\n",(0,s.jsxs)(t.p,{children:["Next, the client will ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#update-timestamp",children:"download"})," the timestamp metadata file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +---------------+\n  | Producer  |         | TUF Repository      | <-----------  | TUF Consumer  |\n  |-----------+ update  |---------------------+               |---------------|\n  | Keys      | ------\x3e | Metadata            | ------------\x3e | Metadata      |\n  +-----------+         | 1.root.json         |               | root.json     |\n  | Metadata  |         | 1.targets.json      |               | timestamp.json|\n  | root.json |         | 1.snapshot.json     |               +---------------+\n  +-----------+         | timestamp.json      |\n  | thing_v1  |         +---------------------+\n  +-----------+         | thing_v1            |\n                        +---------------------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"And there will number of verifications performed on timestamp.json."}),"\n",(0,s.jsxs)(t.p,{children:["Next, the client will ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#update-snapshot",children:"download"})," the snapshot metadata file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +---------------+\n  | Producer  |         | TUF Repository      | <-----------  | TUF Consumer  |\n  |-----------+ update  |---------------------+               |---------------|\n  | Keys      | ------\x3e | Metadata            | ------------\x3e | Metadata      |\n  +-----------+         | 1.root.json         |               | root.json     |\n  | Metadata  |         | 1.targets.json      |               | timestamp.json|\n  | root.json |         | 1.snapshot.json     |               | snapshot.json |\n  +-----------+         | timestamp.json      |               +---------------+\n  | thing_v1  |         +---------------------+\n  +-----------+         | thing_v1            |\n                        +---------------------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"And there will number of verifications performed on snapshot.json."}),"\n",(0,s.jsxs)(t.p,{children:["Next, the client will ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#update-targets",children:"download"})," the targets.json metadata file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  +-----------+         +---------------------+               +---------------+\n  | Producer  |         | TUF Repository      | <-----------  | TUF Consumer  |\n  |-----------+ update  |---------------------+               |---------------|\n  | Keys      | ------\x3e | Metadata            | ------------\x3e | Metadata      |\n  +-----------+         | 1.root.json         |               | root.json     |\n  | Metadata  |         | 1.targets.json      |               | timestamp.json|\n  | root.json |         | 1.snapshot.json     |               | snapshot.json |\n  +-----------+         | timestamp.json      |               | targets.json  |\n  | thing_v1  |         +---------------------+               +---------------+\n  +-----------+         | thing_v1            |\n                        +---------------------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"And there will number of verifications performed on targets.json."}),"\n",(0,s.jsxs)(t.p,{children:["Finally, the client will ",(0,s.jsx)(t.a,{href:"https://theupdateframework.github.io/specification/latest/index.html#fetch-target",children:"fetch"})," the actual target files, these are the actual artifacts."]}),"\n",(0,s.jsx)(t.p,{children:"The names of the metadata files are named after the four top level roles in TUF:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Root"})," Delegates trust to specific keys for all the other top level roles"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Target"})," Signs metadata for the target files"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Snapshot"})," Signs metadata about the latest version of targets metadata"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Timestamp"})," Signs metadata about the latest version of the snapshot metadata"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The following sections will take a closer look at these metadata files."}),"\n",(0,s.jsx)(t.h4,{id:"root-metadata",children:"Root Metadata"}),"\n",(0,s.jsx)(t.p,{children:"Instead of having a single root key, there will often be multiple root keys\nwhich are stored in different offline locations, meaning that they are not\naccessible remotely. These are often hardware keys, like Yubikeys."}),"\n",(0,s.jsx)(t.p,{children:"Root keys are often used together to sign other keys. These non-root keys can\nthen be re-signed/revoked/rotated if/when needed."}),"\n",(0,s.jsx)(t.p,{children:"Each role has metadata associated with it, and the specification defines a\ncanonical json format for them. So there would be a root.json, a targets.json,\na, timestamps.json, and a snapshot.json."}),"\n",(0,s.jsx)(t.p,{children:"So what do these file look like?"}),"\n",(0,s.jsxs)(t.p,{children:["Lets try this out by using a tool called\n",(0,s.jsx)(t.a,{href:"https://github.com/awslabs/tough/tree/develop/tuftool",children:"tuftool"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ cargo install --force tuftool\n"})}),"\n",(0,s.jsx)(t.h4,{id:"root-metadata-1",children:"Root metadata"}),"\n",(0,s.jsxs)(t.p,{children:["Next we initiate a new ",(0,s.jsx)(t.code,{children:"root.json"})," file using the following command:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root init root/root.json\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This command will generate a file named ",(0,s.jsx)(t.code,{children:"root/root.json"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ cat root/root.json\n{\n  "signed": {\n    "_type": "root",\n    "spec_version": "1.0.0",\n    "consistent_snapshot": true,\n    "version": 1,\n    "expires": "2023-01-17T07:48:23Z",\n    "keys": {},\n    "roles": {\n      "timestamp": {\n        "keyids": [],\n        "threshold": 1507\n      },\n      "root": {\n        "keyids": [],\n        "threshold": 1507\n      },\n      "snapshot": {\n        "keyids": [],\n        "threshold": 1507\n      },\n      "targets": {\n        "keyids": [],\n        "threshold": 1507\n      }\n    }\n  },\n  "signatures": []\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["These are just the default values, and we can see that there are no root keys,\nthat field is just an empty object, and notice that the roles are mainly empty\napart from the ",(0,s.jsx)(t.code,{children:"threshold"})," values which is 1507. The threshold value specifies\nthe minimum number of keys required to sign that roles metadata. 1507 is a large\nnumber of keys and we can change this to just requiring one key:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root set-threshold root/root.json snapshot 1\n$ tuftool root set-threshold root/root.json root 1\n$ tuftool root set-threshold root/root.json timestamp 1\n$ tuftool root set-threshold root/root.json targets 1\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And we can see that ",(0,s.jsx)(t.code,{children:"root/root.json"})," has been updated:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'$ cat root/root.json\n{\n  "signed": {\n    "_type": "root",\n    "spec_version": "1.0.0",\n    "consistent_snapshot": true,\n    "version": 1,\n    "expires": "2023-02-27T14:05:04Z",\n    "keys": {},\n    "roles": {\n      "root": {\n        "keyids": [],\n        "threshold": 1\n      },\n      "targets": {\n        "keyids": [],\n        "threshold": 1\n      },\n      "snapshot": {\n        "keyids": [],\n        "threshold": 1\n      },\n      "timestamp": {\n        "keyids": [],\n        "threshold": 1\n      }\n    }\n  },\n  "signatures": []\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"We can also set the expire time for the root using the following command:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root expire root/root.json 'in 6 weeks'\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now, to sign anything we will need a private key to create the signatures and\na matching public key to be used to verify signatures."}),"\n",(0,s.jsxs)(t.p,{children:["We can generate a root key and one can be generated using\n",(0,s.jsx)(t.code,{children:"tuftool root gen-rsa-key"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root gen-rsa-key root/root.json ./keys/root.pem --role root\n6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This will generate keys/root.pem which is a private key in pkcs8 format. The\nhex value printed above is the ",(0,s.jsx)(t.code,{children:"key_id"})," which will be used later to reference\nthis key in metadata files."]}),"\n",(0,s.jsxs)(t.p,{children:["Now, if we again inspect ",(0,s.jsx)(t.code,{children:"root.json"})," we find that a key has been added:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ cat root/root.json\n{\n  "signed": {\n    "_type": "root",\n    "spec_version": "1.0.0",\n    "consistent_snapshot": true,\n    "version": 1,\n    "expires": "2023-02-28T08:30:48Z",\n    "keys": {\n      "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f": {\n        "keytype": "rsa",\n        "keyval": {\n          "public": "-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ZiWzak3CBJkRrCfw5GO\\nSUtYjIK2jLozyaZ44FePW/KYEhM8LyHcNz9lwx45tZ8gId4AsxGBj9fhsOgjpN7l\\nMPXpaKsV/5f37HzQLCrbldz3ei9LkMWG5La4Cwil0qPDpTxfzI7IWDKk6l4/epgi\\nOrAJDaQ/mKhH5OZ485JYuDIE7a0jplU/GvsNeCdZVMEQ8dko/CA4Di8lPkDRRdSw\\naC/8g3K6mF+87ADdGOmZ+LFodLEPvqIVljece2JlX2z44Io3N7Y5FH63Az4H3MFL\\nDPZJH5lFs7Lb/fHx25rWSE2/GHcUUTs4oScPp2X0hAnblOsmCFSCjf8Kb0R7dLUb\\nnQIDAQAB\\n-----END PUBLIC KEY-----"\n        },\n        "scheme": "rsassa-pss-sha256"\n      }\n    },\n    "roles": {\n      "timestamp": {\n        "keyids": [],\n        "threshold": 1\n      },\n      "targets": {\n        "keyids": [],\n        "threshold": 1\n      },\n      "root": {\n        "keyids": [\n          "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f"\n        ],\n        "threshold": 1\n      },\n      "snapshot": {\n        "keyids": [],\n        "threshold": 1\n      }\n    }\n  },\n  "signatures": []\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that the ",(0,s.jsx)(t.code,{children:"keys"})," object has a field which is named after the ",(0,s.jsx)(t.code,{children:"key_id"})," and\nthat the ",(0,s.jsx)(t.code,{children:"root"})," role has this ",(0,s.jsx)(t.code,{children:"key_id"})," in its ",(0,s.jsx)(t.code,{children:"keyids"})," array. This ",(0,s.jsx)(t.code,{children:"key_id"})," is\ncreated from the json value of the fields ",(0,s.jsx)(t.code,{children:"keytype"}),", ",(0,s.jsx)(t.code,{children:"keyval"}),", and ",(0,s.jsx)(t.code,{children:"scheme"}),",\nwhich is then canonicalized before hashed using sha256. We can inspect/verify\nthis using a tool named ",(0,s.jsx)(t.a,{href:"https://github.com/danbev/tuf-keyid",children:"tuf-keyid"}),", and\npassing in the above json field of the public key:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ tuf-keyid --json=\'{\n            "keytype": "rsa",\n            "keyval": {\n              "public": "-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ZiWzak3CBJkRrCfw5GO\\nSUtYjIK2jLozyaZ44FePW/KYEhM8LyHcNz9lwx45tZ8gId4AsxGBj9fhsOgjpN7l\\nMPXpaKsV/5f37HzQLCrbldz3ei9LkMWG5La4Cwil0qPDpTxfzI7IWDKk6l4/epgi\\nOrAJDaQ/mKhH5OZ485JYuDIE7a0jplU/GvsNeCdZVMEQ8dko/CA4Di8lPkDRRdSw\\naC/8g3K6mF+87ADdGOmZ+LFodLEPvqIVljece2JlX2z44Io3N7Y5FH63Az4H3MFL\\nDPZJH5lFs7Lb/fHx25rWSE2/GHcUUTs4oScPp2X0hAnblOsmCFSCjf8Kb0R7dLUb\\nnQIDAQAB\\n-----END PUBLIC KEY-----"\n            },\n            "scheme": "rsassa-pss-sha256"\n    }\'\n\nkey_id: SHA256:6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f\n'})}),"\n",(0,s.jsxs)(t.p,{children:["And we can see that the ",(0,s.jsx)(t.code,{children:"key_id"}),"'s produced are the same. This may be obvious\nbut just to be clear, ",(0,s.jsx)(t.code,{children:"keys"})," only includes the public key."]}),"\n",(0,s.jsx)(t.h4,{id:"targets-metadata",children:"Targets metadata"}),"\n",(0,s.jsx)(t.p,{children:"The Target role is a role that signs metadata files that describe the\nproject artifacts, like software packages, source code, or whatever artifacts\nthat are to be consumed by TUF clients/consumers."}),"\n",(0,s.jsx)(t.p,{children:"So lets add a target key, and we will use the same private key as before:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root add-key root/root.json ./keys/root.pem --role targets\n6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This will update the ",(0,s.jsx)(t.code,{children:"targets"})," role in ",(0,s.jsx)(t.code,{children:"root.json"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ jq \'.signed.roles.targets\' < root/root.json\n{\n  "keyids": [\n    "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f"\n  ],\n  "threshold": 1\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"snapshot-metadata",children:"Snapshot metadata"}),"\n",(0,s.jsx)(t.p,{children:"The Snapshot roles signs a metadata file which contains information about the\nlatest version of the targets metadata. This is used to identify which versions\nof a target are in a repository at a certain time. This is used to know if there\nis an update available (remember it's call The Update Framework)."}),"\n",(0,s.jsx)(t.p,{children:"So, lets add a key to the snapshot role:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root add-key root/root.json ./keys/root.pem --role snapshot\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And we can see that following change to ",(0,s.jsx)(t.code,{children:"root.json"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ jq \'.signed.roles.snapshot\' < root/root.json\n{\n  "keyids": [\n    "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f"\n  ],\n  "threshold": 1\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"timestamp-metadata",children:"Timestamp metadata"}),"\n",(0,s.jsx)(t.p,{children:"Finally, we have the timestamp role which tells if there is an update."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root add-key root/root.json ./keys/root.pem --role timestamp\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And we can see that following change to ",(0,s.jsx)(t.code,{children:"root.json"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ jq \'.signed.roles.timestamp\' < root/root.json\n{\n  "keyids": [\n    "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f"\n  ],\n  "threshold": 1\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"signing-rootjson",children:"Signing root.json"}),"\n",(0,s.jsx)(t.p,{children:"So we have configured which keys to be used for each of the roles but we have\nnot signed this metadata file. We need to sign it to prevent tampering of it\nas it will be sent to the TUF repository, usually on server but for this\nexample everything will be on the local file system."}),"\n",(0,s.jsx)(t.p,{children:"We can now sign root.json using the following command:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool root sign ./root/root.json -k ./keys/root.pem\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And we can check ",(0,s.jsx)(t.code,{children:"root.json"})," that the signatures field has been updated with\na keyid and a signature."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:' jq \'.signatures\' < root/root.json\n[\n  {\n    "keyid": "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f",\n    "sig": "8e7c7ca88e242ff360af30ba83e0ccfd9de2a9dee774166abe508ad2757620d6439bc7a5163c55867e069812a21ba31b7097d9ded3590f03f8bdc7106755a9ae840efbfe9b6c7d69e047230c59f3bd682e83f0b5b9c271d6db60943f7fa57d565790de58687560b50951a363725471c3a8f64c3980385eb214876bb1fe87d4aefc5cdd557bd022ddd794a52368f8502c1944185c75827ca97bba8fd5cdd5bb41b7ad76f0105072fbee980d3dbbf9889ec223ea1399228560fd747bc03a378d3ba93990560b000d02a59aab04844ec70662f8baaee33f8591f5bbe3126fb057f9b3055d498005220d1715c92166506995e89f2e8e62d1032452d51ba6579eb0e2"\n  }\n]\n'})}),"\n",(0,s.jsx)(t.h4,{id:"generate-the-tuf-repository",children:"Generate the TUF repository"}),"\n",(0,s.jsxs)(t.p,{children:["With ",(0,s.jsx)(t.code,{children:"root.json"})," and the private key we can generate a tuf repository using the\nfollowing command:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ tuftool create \\\n  --root root/root.json \\\n  --key keys/root.pem \\\n  --add-targets artifacts \\\n  --targets-expires 'in 3 weeks' \\\n  --targets-version 1 \\\n  --snapshot-expires 'in 3 weeks' \\\n  --snapshot-version 1 \\\n  --timestamp-expires 'in 1 week' \\\n  --timestamp-version 1 \\\n  --outdir repo\n"})}),"\n",(0,s.jsxs)(t.p,{children:["That command will create a directory named ",(0,s.jsx)(t.code,{children:"repo"})," which contains two\ndirectories, ",(0,s.jsx)(t.code,{children:"metadata"})," and ",(0,s.jsx)(t.code,{children:"targets"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Let start by looking at the ",(0,s.jsx)(t.code,{children:"targets"})," directory:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ ls -l repo/targets/01ab0faaf41a4543df1fa218b8e9f283d07536339cf11d2afae9d116a257700c.artifact_1.txt\nlrwxrwxrwx. 1 danielbevenius danielbevenius 79 Jan 17 12:50 repo/targets/01ab0faaf41a4543df1fa218b8e9f283d07536339cf11d2afae9d116a257700c.artifact_1.txt -> artifacts/artifact_1.txt\n"})}),"\n",(0,s.jsx)(t.p,{children:"Notice that the name of this link is the sha256sum of the contents of\nartifact_1.txt file:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ sha256sum  artifacts/artifact_1.txt\n01ab0faaf41a4543df1fa218b8e9f283d07536339cf11d2afae9d116a257700c  artifacts/artifact_1.txt\n"})}),"\n",(0,s.jsx)(t.p,{children:"And we can check the size of this file using:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ stat -c "%s" artifact_1.txt\n24\n'})}),"\n",(0,s.jsx)(t.p,{children:"The reason for showing this values is that they are referred to in the next\nsection."}),"\n",(0,s.jsxs)(t.p,{children:["Now, lets take a look at the ",(0,s.jsx)(t.code,{children:"metadata"})," directory."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ ls repo/metadata/\n1.root.json  1.snapshot.json  1.targets.json  timestamp.json\n"})}),"\n",(0,s.jsx)(t.p,{children:"The number prefix is the version, to 1.targets.json is for version 1 for\nexample."}),"\n",(0,s.jsxs)(t.p,{children:["Lets start by looking at ",(0,s.jsx)(t.code,{children:"targets.json"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "signed": {\n    "_type": "targets",\n    "spec_version": "1.0.0",\n    "version": 1,\n    "expires": "2023-02-07T11:50:00.608598188Z",\n    "targets": {\n      "artifact_1.txt": {\n        "length": 24,\n        "hashes": {\n          "sha256": "01ab0faaf41a4543df1fa218b8e9f283d07536339cf11d2afae9d116a257700c"\n        }\n      }\n    },\n    "delegations": {\n      "keys": {},\n      "roles": []\n    }\n  },\n  "signatures": [\n    {\n      "keyid": "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f",\n      "sig": "48b9810f275e16acb2d093c5487da4107f2312e0c9e084f6974aa836661a0e87d341be37fe84a4afd6ba82e8e54301e01a7431a0e69d3bef95ce3e34d90badff3c4a19ed7a6cea2a4ec69c6dc7392fde1f20b1246f3113ace85a223bfc54203a9254e82c8cd9686b8b973bfc41cdda657ff707a41c3db125b61dfc41c8937896f7fcc0ea17429a934b9c0fee912ca4df4a3b1dac6811968aa34bbf2d3327bbeab9cad1dadc1f8134c0add4267bf8ff285c066d24ea39b24d9bca197bf9762025133205612d41b167ee1232adf8c122320d77b70b936817ddf2cc93732228f772078b663f3fc896ec8873873414ba44fd3e28772589f69af06ee3e1297e0b2b37"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that the ",(0,s.jsx)(t.code,{children:"hashes"})," object has a single field which is the sha256sum of\nthe file ",(0,s.jsx)(t.code,{children:"artifacts_1.txt"}),", and that ",(0,s.jsx)(t.code,{children:"length"})," matches the size which we showed\nin the previous section."]}),"\n",(0,s.jsxs)(t.p,{children:["We have information about the targets, in this case on a single file named\nartifact_1.txt, and this is the file that a client wants to consume. This\nmetadata file is signed and the signature in the ",(0,s.jsx)(t.code,{children:"sig"})," field of the\n",(0,s.jsx)(t.code,{children:"signatures"})," array."]}),"\n",(0,s.jsxs)(t.p,{children:["Again, this needs to be signed to prevent an attacker from modifying the targets\nand modifying the ",(0,s.jsx)(t.code,{children:"length"}),", and ",(0,s.jsx)(t.code,{children:"sha256"})," fields which would otherwise allow them\nto replace the target artifact with a potentially malicious version."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, lets take a look at the ",(0,s.jsx)(t.code,{children:"snapshots.json"})," metadata file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ cat repo/metadata/1.snapshot.json\n{\n  "signed": {\n    "_type": "snapshot",\n    "spec_version": "1.0.0",\n    "version": 1,\n    "expires": "2023-02-07T11:50:00.608597347Z",\n    "meta": {\n      "targets.json": {\n        "length": 1048,\n        "hashes": {\n          "sha256": "896781ff1260ed4ad5b05a004b034279219dc92b64068a2cc376604e8a6821c9"\n        },\n        "version": 1\n      }\n    }\n  },\n  "signatures": [\n    {\n      "keyid": "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f",\n      "sig": "5a8d9597329183c52547591d1abc8e36c1535d81c0e51ed51d95d2ddf1ec2076f2412ba8e631f039c7bf9e5a14cdd44eb7a5c7dae5dcc84e6aa2ebd51049ee791cf3c3dc486af26731fc06ba39e449ef85b102247c4254cb48784e4a95b54943df9e668470a6def79c7c3d532a68e93d18f1d59f1636455dddec0b5960afeb5a9ac38c38c6891e6f819f22aed7996a7f9964d655d634a940e1234f2015caa8f4f710570443bc0bc3ec04117c3dc97c8d564f42489cc499593f6232b7f5062646644aecafaf50dc9a4005a000f6720b0b9c455e5b92d7a1bcfb96f14a6a9da162e9b091497b0eb24283a837ba1d15ff67f12d104b1c5e1d83c36ae49400bb326e"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["So looking at the above ",(0,s.jsx)(t.code,{children:"meta"})," field, we can see that there is a ",(0,s.jsx)(t.code,{children:"targets.json"}),'\n"meta path". If we search for this file we won\'t be able to find it. The actual\nfile is prefixed with the version from the ',(0,s.jsx)(t.code,{children:"version"})," field. So the file in\nquestion is ",(0,s.jsx)(t.code,{children:"repo/metadata/1.targets.json"}),", and we can check the size of this\nfile using:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ stat -c "%s" repo/metadata/1.targets.json\n1048\n'})}),"\n",(0,s.jsxs)(t.p,{children:["And that matches the ",(0,s.jsx)(t.code,{children:"length"})," field above."]}),"\n",(0,s.jsx)(t.p,{children:"And we also can check the hash using:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:"$ sha256sum repo/metadata/1.targets.json\n896781ff1260ed4ad5b05a004b034279219dc92b64068a2cc376604e8a6821c9  repo/metadata/1.targets.json\n"})}),"\n",(0,s.jsx)(t.p,{children:"The snapshot metadata file tells us which versions of metadata files\nexisted for a specific version. Even though we only have one version currently\nin our example, a real world repositories would have multiple versions of\nmetadata files. The purpose of the snapshot.json file is to prevent an attacker\nfrom including metadata files from another version in some version:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"       TUF Repository              TUF Client\n     +----------------+           +----------------+\n     | timestamp.json | --------\x3e | timestamp.json |\n     | 1.targets.json | version 3 | - version 3    |\n     | 2.targets.json | <-------  |                |\n     | 3.targets.json | version 2 |                |\n     |                | --------\x3e |                |\n     +----------------+           +----------------+kk\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The above is trying to show that the client has received a timestamp.json,\nwhich we will discuss shortly, with a version number of 3. The client proceeds\nto retrieve this version update from the TUF server. Now if an attacker was able\nto include other metadata files, which are available in the TUF repository only\nthey are not part of the request version, it would be possible for them those\ntargets to be sent to the client.Having the ",(0,s.jsx)(t.code,{children:"snapshot.json"})," prevents this as\nit specifies which metadata files are included in a specific version and no\nother additional metadata files that may exist in the TUF repository are\nincluded."]}),"\n",(0,s.jsxs)(t.p,{children:["So that leaves us with ",(0,s.jsx)(t.code,{children:"timestamp.json"}),". This is a file that is downloaded by\nthe client and usually has a short expiration date. As mentioned before this is\nthe part that allows the system to enforce that updates are actually reaching\nconsumers, and if they are not they allow the consumer to take action."]}),"\n",(0,s.jsx)(t.p,{children:"The metadata looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-console",children:'$ cat repo/metadata/timestamp.json\n{\n  "signed": {\n    "_type": "timestamp",\n    "spec_version": "1.0.0",\n    "version": 1,\n    "expires": "2023-01-24T11:50:00.608598985Z",\n    "meta": {\n      "snapshot.json": {\n        "length": 1004,\n        "hashes": {\n          "sha256": "b92c443c21b6bc15d4f3991491e8bcb201f66a26ab289fb8cc9af7f851530872"\n        },\n        "version": 1\n      }\n    }\n  },\n  "signatures": [\n    {\n      "keyid": "6e99ec437323f2c7334c8b16fd7a7a197829ba89ff50d07aa4b50fc9634dad9f",\n      "sig": "3708f055fe58b2c70e92cbc46bd9cc0f3149900bf25b3e924ff666eb8b45187df8d1f064b249cd790c170b5e97b322866d298d527ff950d2fbcbf508097868afca34ebaa159890799155c6bb615bab9a8bcfc34a39574584716d9a89b531fce97d876884fad2db69dc8f3569870dee280e87c9d506b5b08698e7c23e7dbbf4a3209fbc91ec764b54bf87367145cbb7bc9d7edaf47f709355284315fac9167312833d990e9e064852bb4fa905ec4edb5fe051480e70d505694528c5e9b47fefc3b78f6e54623f93344511326bdeec392a5eac31e7299bf9f602036d9f9524810eb03c4720370250f3e9f503e8d5bee94a6e6539ca9f988a27272d47612fd03436"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that ",(0,s.jsx)(t.code,{children:"snapshot.json"})," is refering to the file ",(0,s.jsx)(t.code,{children:"1.timestamp.json"})," in the\nTUF repository."]}),"\n",(0,s.jsx)(t.p,{children:"Finally, we have repo/metadata/1.root.json which is identical to root/root.json\nwhich we saw previously as this is the only version we have in our repository."}),"\n",(0,s.jsx)(t.p,{children:"What we have been doing is setting up a repository which would be most often\nexist on on a server somewhere."}),"\n",(0,s.jsx)(t.h3,{id:"tuf-clientconsumer",children:"TUF client/consumer"}),"\n",(0,s.jsx)(t.p,{children:"A consumer of the artifact would use a TUF client library to download the\nartifacts, and would specify the metadata and targets to download."}),"\n",(0,s.jsxs)(t.p,{children:["To make this more concrete we have created a very basic ",(0,s.jsx)(t.a,{href:"https://github.com/danbev/tuf-client#readme",children:"example"}),"\nwhich is intended to show how one such client library, in this case\n",(0,s.jsx)(t.a,{href:"https://crates.io/crates/tough",children:"tough"}),", might be used. Please refer to the\nexample's README.md for details."]}),"\n",(0,s.jsx)(t.h3,{id:"tuf-usage-in-sigstore",children:"TUF usage in Sigstore"}),"\n",(0,s.jsx)(t.p,{children:"Armed with the above knowledge, lets take a look at how Sigstore uses TUF."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/root-signing/tree/main/repository",children:"root-signing"}),"\nrepository has a directory which contains the TUF repository metadata."]}),"\n",(0,s.jsxs)(t.p,{children:['Sigstore uses TUF to protect their public keys and certificates, which was one\nreason for trying to say "things" instead of software updates in the text above.\nSo the artifacts that are updated are public keys and certificates. As of this\nwriting these are the current ',(0,s.jsx)(t.a,{href:"https://github.com/sigstore/root-signing/blob/0ce4aa6c45c3ee709766d90e34c6b1372ad4b29a/repository/repository/targets.json",children:"targets"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"fulcio.crt.pem  Fulico (CA) certificate.\nrekor.pub       Rekor public key.\nctfe.pub        Certificate Transparency log public key used to verify\n                signed certificate timestamps.\nartifact.pub    Public key which is used to verify Sigstore releases, like\n                Cosign, Rekor, and Fulcio releases.\n"})}),"\n",(0,s.jsx)(t.p,{children:"There are more than four in the actual file but they are different versions. The\nfour listed here just explain the usage of these keys. In the case of\nsigstore-rs only the Fulio certificate, and Rekor's public key are used. We will\nfocus on these in this post."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/root-signing/blob/main/repository/repository/root.json",children:"root.json"}),"\ncan also be found in the same directory and hopefully this should look familar\nafter seeing the root.json earlier."]}),"\n",(0,s.jsxs)(t.p,{children:["We also learned earlier that the initial trusted ",(0,s.jsx)(t.code,{children:"root.json"})," is shipped with the\nsoftware in some manner. In sigstore-rs, ",(0,s.jsx)(t.code,{children:"root.json"})," is a constant named\n",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/sigstore-rs/blob/8d22a6d23a6771688c8206850524a2b1076bbdb0/src/tuf/constants.rs#L30-L173",children:"SIGSTORE_ROOT"})," in the crate itself."]}),"\n",(0,s.jsxs)(t.p,{children:["sigstore-rs uses the ",(0,s.jsx)(t.code,{children:"tough"})," crate just like the example we saw earlier, and\nsimilar to the ",(0,s.jsx)(t.a,{href:"https://github.com/danbev/tuf-client/blob/3adca52130c69f242ef24c5845c91ee1612fc64c/src/main.rs#L61",children:"example"}),", creates a tough ",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/sigstore-rs/blob/cef673776548c9b268e0ce8ecc3a4fe2da504658/src/tuf/repository_helper.rs#L43",children:"RepositoryLoader"})," in a RepositoryHelper\nstruct. A RepositoryHelper is created in SigstoreRepository's\n",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/sigstore-rs/blob/cef673776548c9b268e0ce8ecc3a4fe2da504658/src/tuf/mod.rs#L123",children:"fetch"})," method, and the ",(0,s.jsx)(t.code,{children:"Fulcio certificate"}),", and ",(0,s.jsx)(t.code,{children:"Rekor's public key"})," are read from\nthe repository, similar to how ",(0,s.jsx)(t.code,{children:"artifact.txt"})," was read in the example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'    let repository_helper = RepositoryHelper::new(\n        SIGSTORE_ROOT.as_bytes(),\n        metadata_base,\n        target_base,\n        checkout_dir,\n    )?;\n\n    let fulcio_certs = repository_helper.fulcio_certs()?;\n\n    let rekor_pub_key = repository_helper.rekor_pub_key().map(|data| {\n        String::from_utf8(data).map_err(|e| {\n            SigstoreError::UnexpectedError(format!(\n                "Cannot parse Rekor\'s public key obtained from TUF repository: {}",\n                e\n            ))\n        })\n    })??;\n'})}),"\n",(0,s.jsxs)(t.p,{children:["There is a caching layer in-between the call to ",(0,s.jsx)(t.code,{children:"fulcio_certs"})," but after\nthat, and if there is a cache miss, the actual call the TUF repository can\nbe found in ",(0,s.jsx)(t.a,{href:"https://github.com/sigstore/sigstore-rs/blob/cef673776548c9b268e0ce8ecc3a4fe2da504658/src/tuf/repository_helper.rs#L158",children:"fetch_target"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"/// Download a file from a TUF repository\nfn fetch_target(repository: &tough::Repository, target_name: &TargetName) -> Result<Vec<u8>> {\n    let data: Vec<u8>;\n    match repository.read_target(target_name)? {\n        None => Err(SigstoreError::TufTargetNotFoundError(\n            target_name.raw().to_string(),\n        )),\n        Some(reader) => {\n            data = read_to_end(reader)?;\n            Ok(data)\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And this is simliar to how in the example above we ",(0,s.jsx)(t.a,{href:"https://github.com/danbev/tuf-client/blob/3adca52130c69f242ef24c5845c91ee1612fc64c/src/main.rs#L69-L71",children:"downloaded"})," ",(0,s.jsx)(t.code,{children:"artifact.txt"})," like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'    let artifact = repository\n        .read_target(&TargetName::from_str("artifact.txt").unwrap())\n        .unwrap();\n'})}),"\n",(0,s.jsx)(t.p,{children:"By using the TUF framework for Fulcio's certificate, and Rekor's public keys\nthese can be updated in a secure manner like described previously in this post."})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);