"use strict";(self.webpackChunktrustification_io=self.webpackChunktrustification_io||[]).push([[5318],{3120:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=n(4848),a=n(8453);const o={title:"Signing elf binaries, or not?! Lessons learned.",authors:"ctron",tags:[]},s=void 0,r={permalink:"/blog/2023/02/13/elfsign",editUrl:"https://github.com/trustification/trustification.github.io/tree/main/blog/2023-02-13-elfsign.md",source:"@site/blog/2023-02-13-elfsign.md",title:"Signing elf binaries, or not?! Lessons learned.",description:"Trying to figure out what went into a binary can be a tricky thing. And once you figured it out, how do you",date:"2023-02-13T00:00:00.000Z",tags:[],readingTime:8.66,hasTruncateMarker:!0,authors:[{name:"Jens Reimann",title:"Maintainer",url:"https://github.com/ctron",imageURL:"https://github.com/ctron.png",key:"ctron"}],frontMatter:{title:"Signing elf binaries, or not?! Lessons learned.",authors:"ctron",tags:[]},unlisted:!1,prevItem:{title:"in-toto attestations",permalink:"/blog/2023/03/13/in-toto-attestations"},nextItem:{title:"Continuing the Adventure with the CycloneDX Maven Plugin",permalink:"/blog/2023/02/10/cyclonedx-maven-plugin-adventure-continues"}},l={authorsImageUrls:[void 0]},d=[{value:"SBOMs",id:"sboms",level:2},{value:"What really goes in",id:"what-really-goes-in",level:2},{value:"Null and void",id:"null-and-void",level:2},{value:"Usability",id:"usability",level:2},{value:"Back to binaries",id:"back-to-binaries",level:2},{value:"Solvable downsides",id:"solvable-downsides",level:2},{value:"Too good to be true?",id:"too-good-to-be-true",level:2},{value:"Happy end?",id:"happy-end",level:2},{value:"So what?",id:"so-what",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",section:"section",sup:"sup",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Trying to figure out what went into a binary can be a tricky thing. And once you figured it out, how do you\ntransport this information? True, it all starts simple: Java, NodeJS, Go, or Rust, all languages",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1-84d680",id:"user-content-fnref-1-84d680","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," bring their\ndependency management, which defines what the final command line tool you create is made of. Or, does it?"]}),"\n",(0,i.jsxs)(t.p,{children:["But let's take a step back: A typical use-case today is to download a command line application from the internet.\nTake ",(0,i.jsx)(t.code,{children:"helm"})," for example. You navigate to their GitHub releases page, download the binary, unzip it into a local\nfolder and run it. But, what exactly is inside the binary?"]}),"\n",(0,i.jsx)(t.h2,{id:"sboms",children:"SBOMs"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Software Bills of Material"})," (SBOMs) are a thing which already exist. Yet, someone needs to create them,\nand creating an accurate SBOM can be tricky."]}),"\n",(0,i.jsxs)(t.p,{children:["There are tools to create SBOMs from the source code of a project, but that doesn't tell the whole story in\nmost cases. Those tools simply analyze the dependency information declared in e.g. a ",(0,i.jsx)(t.code,{children:"package.lock"})," file, or a Maven ",(0,i.jsx)(t.code,{children:"pom.xml"}),'. Should be enough, right? Well, no. Maven projects for example have "profiles", and you\nneed to exactly generate the SBOM for the profile that gets enabled when creating the final artifact. Also,\nwith Maven mirrors and proxies, it\'s not always 100% clear what gets into a "binary" and where it comes from.']}),"\n",(0,i.jsx)(t.h2,{id:"what-really-goes-in",children:"What really goes in"}),"\n",(0,i.jsxs)(t.p,{children:["Then again, JAR files aren't real binaries are they. They are ZIP files, which contain compiled ",(0,i.jsx)(t.code,{children:".class"}),' files. So\nit actually is pretty simple to understand what is in there. Assuming you trust your build process\n(which is a topic of its own). Even if you create a "fat", or "shaded" JAR, it is possible to understand what\nreally ended up in your "binary".']}),"\n",(0,i.jsxs)(t.p,{children:["And, others can do the same. Rust for example allows one use ",(0,i.jsx)(t.code,{children:"cargo auditable"}),", to tap into the compilation process,\nand record the actual dependencies which go into a binary. On Linux, the binary will be an ELF file, which then\ncontains the dependency information from the compilation process. And Go can do the same."]}),"\n",(0,i.jsx)(t.h2,{id:"null-and-void",children:"Null and void"}),"\n",(0,i.jsx)(t.p,{children:"But, if someone can write dependency information into a binary, then someone else can also overwrite it. So\nunless you protect the binary against modifications, this information isn't really trustworthy. Taking a look at\nthe Helm release page, you will find SHA based checksums. Isn't that enough?"}),"\n",(0,i.jsx)(t.p,{children:"No, not really. Because if someone can alter the binary on the download page, the attacker can also swap out the\nSHA checksum file. The checksum, or digest, really isn't more than a checksum. By its own, it doesn't protect much."}),"\n",(0,i.jsx)(t.p,{children:'If however, you encrypt the digest with a private key that only the author knows, and you publish the public key\npart, then this becomes a "signature". And this is good enough to prove, that only the person how knew the private\nkey, could have signed the binary. And if we can trust this person to create the correct SBOM and binary, and keep\nthe private key secure, we are good.'}),"\n",(0,i.jsx)(t.h2,{id:"usability",children:"Usability"}),"\n",(0,i.jsx)(t.p,{children:"Or, not! In the Maven world JARs have been signed for quite a while. Everyone uploading JARs to Maven Central needs\nto sign their JAR with GPG. And I guess most people never validated a JAR during a build."}),"\n",(0,i.jsx)(t.p,{children:"On the other side, the Eclipse IDE (as well as some other Java applications), did JAR file validation for quite a\nwhile. Whenever you install a plugin, it cryptographically validates the JAR. And it's easy, as the JAR file itself\nis signed, and the signature is part of the JAR file. As part of the build process in the Eclipse Foundation\nbuild system, JARs which got created by the build, can automatically get signed. No additional files needed,\nand only the actual build output is considered, no guessing of dependencies."}),"\n",(0,i.jsx)(t.p,{children:"From a user perspective, the IDE automatically checks signatures, and only bothers the user if an issue was found.\nThe user can override, because the idea is to give the final authority to the user."}),"\n",(0,i.jsx)(t.h2,{id:"back-to-binaries",children:"Back to binaries"}),"\n",(0,i.jsxs)(t.p,{children:["Now, just assume we could do the same with (ELF) binaries. In fact this was possible a while back, Solaris had some\ntools to sign ELF binaries. That doesn't help on modern Linux systems. But with a bit of Rust code, it was possible\nto create ",(0,i.jsx)(t.a,{href:"https://github.com/ctron/elfsign",children:"elfsign"}),". The idea is simple:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Create a digest of all relevant ELF sections and headers"}),"\n",(0,i.jsx)(t.li,{children:"Sign this digest"}),"\n",(0,i.jsx)(t.li,{children:"Add the signature to the ELF binary as a new section"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"solvable-downsides",children:"Solvable downsides"}),"\n",(0,i.jsx)(t.p,{children:"The first downside might be that people are afraid of signed binaries. Windows and macOS have been doing this for a\nwhile, and it happens that signatures get in the way of the user running a binary. Well, actually it is the operating\nsystem which gets into the user's way. To protect the user, that's the argument. And that might be true, but it also\nis true that some users indeed know better than the operating system and want to have the final word in what they\ncan run."}),"\n",(0,i.jsx)(t.p,{children:"This problem can easily be addressed. Checking a signature, and making a decision if a binary can be run or not,\nactually are two different things. Even if a system brings a default rule/policy set which would reject invalid\nsignatures, it could still be possible to let the user customize the behavior and override, just like the\nEclipse IDE does."}),"\n",(0,i.jsx)(t.p,{children:"Another issue the handling of keys and certificates. Prices for code signing certificates can be quite high.\nEspecially when we are talking about open source projects, this can become a truly limiting factor. It also takes a\nbit of care, handling a private key properly."}),"\n",(0,i.jsxs)(t.p,{children:["Luckily, we now have ",(0,i.jsx)(t.a,{href:"https://www.sigstore.dev/",children:"sigstore"}),". Sigstore can help us with two things, creating\nshort-lived private keys (Fulcio), and a tamper-resistant log (Rekor). We already talked a bit about both in\nthe context of [gitsign]({% post_url 2022-12-02-sign-commits-with-sigstore %})."]}),"\n",(0,i.jsxs)(t.p,{children:["Adding Fulcio and Rekor to ",(0,i.jsx)(t.code,{children:"elfsign"}),", we gain a bunch of cool things:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Short-lived, disposable private keys: You don't need to store them, they are only valid for a few minutes."}),"\n",(0,i.jsx)(t.li,{children:"X.509 certificates: Alongside the key, we get an X.509 certificates, with our identity, which we can use for signing."}),"\n",(0,i.jsx)(t.li,{children:"An attestation that we provided the valid certificate and signature to Rekor, at a time the key was valid"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["And with that, we can easily implement ",(0,i.jsx)(t.code,{children:"elfsign sign"})," to sign a binary, and ",(0,i.jsx)(t.code,{children:"elfsign verify"})," to validate one. We\ncould also create something like ",(0,i.jsx)(t.code,{children:"elfsign execute"})," to verify and execute, but that's just a variant of ",(0,i.jsx)(t.code,{children:"verify"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"As we can prove, using Rekor, that we did own the private key during the time the certificate was valid, and we\nprovided the signature/digest at the same time, we now only need to decide if we want to trust the issuer and the\nsubject the certificate was issued for. And by storing [the Rekor bundle]({% post_url 2023-01-13-sigstore-bundle-format %}), we can do this offline too."}),"\n",(0,i.jsx)(t.h2,{id:"too-good-to-be-true",children:"Too good to be true?"}),"\n",(0,i.jsx)(t.p,{children:"So where's the catch?"}),"\n",(0,i.jsxs)(t.p,{children:["Signing elf binaries adds a bit of extra complexity. Creating a digest of an ELF binary isn't as trivial as\njust running ",(0,i.jsx)(t.code,{children:"sha256sum"}),' on a file. Storing an additional "signature section" in the ELF binary, will actually\nalter it. So it is necessary have a normalized view on the ELF binary, which creates a reproducible digest, one that\ndoes include all important information, but excludes the signature information itself, and still is a valid ELF\nbinary format.']}),"\n",(0,i.jsx)(t.p,{children:"It works, but is a bit complex. And more complexity might lead to more bugs, which isn't a good thing when\nit comes to cryptography. But if this allows one to drop handling additional files (like SBOMs or checksum files),\nand increase the usability, it may actually be worth it."}),"\n",(0,i.jsx)(t.p,{children:"The problem is, that the tooling which creates the dependency information for the ELF binaries, isn't\naccurate enough."}),"\n",(0,i.jsx)(t.p,{children:'In many cases it works, but as soon as you include a C library, add some JavaScript for an embedded frontend, or\ndeviate from "standard artifact repositories", many of those tools just fall short. And I am not even talking\nabout all those little hacks in build systems, or the mess called "vendor" folder in Go.'}),"\n",(0,i.jsxs)(t.p,{children:["SBOM formats like ",(0,i.jsx)(t.a,{href:"https://cyclonedx.org/",children:"CycloneDX"})," allow you to compensate and fix up generated SBOMs.\nBut, that's another step in the build process, and the output doesn't go into the ELF binary. As Go only cares\nabout Go dependencies, and Cargo only about Cargo."]}),"\n",(0,i.jsx)(t.p,{children:"So adding all the complexity isn't good enough in the end. You still need to handle an extra file, and validate it."}),"\n",(0,i.jsx)(t.h2,{id:"happy-end",children:"Happy end?"}),"\n",(0,i.jsxs)(t.p,{children:["The truth is, ",(0,i.jsx)(t.code,{children:"cosign"}),", which is intended to sign containers, can actually sign any BLOB. Just the same way,\nusing Fulcio to get a short-lived private key and certificate, and storing the signature in Rekor. So if we can make\nour peace with handling an extra file, we can just use ",(0,i.jsx)(t.code,{children:"cosign sign-blob"})," and ",(0,i.jsx)(t.code,{children:"cosign verify-blob"})," to sign\nanything we want. Using ",(0,i.jsx)(t.code,{children:"cosign attest-blob"}),', we can even "attach" an SBOM to the Rekor log entry.']}),"\n",(0,i.jsx)(t.p,{children:'Yes, we need to handle the extra "bundle" and "signature" files. Or we can accept the fact that we need rely on the\nuptime of the Rekor instance (or our ISP). But it definitely improves the situation over the status quo.'}),"\n",(0,i.jsx)(t.h2,{id:"so-what",children:"So what?"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"elfsign"}),' was a nice experiment. And while it didn\'t work out, I still learned a lot. I also still believe that\nthe idea works out in general. It just needs more work for a more specialized solution. So the approach of\n"cosign blob" is a more generic one. However, through that, also less user-friendly one.']}),"\n",(0,i.jsx)(t.p,{children:'But this situation could also be improved. Just assume someone would create a more convenient version of\ncosign, which "downloads and verifies" or "verifies and executes". That would definitely lead to a similar\nuser experience, and help with adoption.'}),"\n",(0,i.jsx)(t.p,{children:"And, having a policy engine like Seedwing, you could actually define checks like: Only run this binary if it is signed, and does not contain a dependency which has an active CVE."}),"\n",(0,i.jsx)(t.p,{children:"If you are interested in things like this, maybe this blog post gave you a few insights and ideas."}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1-84d680",children:["\n",(0,i.jsxs)(t.p,{children:["Yes, C/C++ is missing here. Let's not talk about build systems and dependency management for C/C++ \ud83d\ude09 ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1-84d680","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);